{
  "name": "Pathology Learning Module: Granulomatous Diseases",
  "description": "An interactive, all-inclusive didactic educational experience for pathology residents on granulomatous diseases of the lung, built using the ADDIE model of instructional design.\n\nInstruction Set: Implementing a Persistent, Multi-User Image Gallery in Google AI Studio\n\n1. System Design Overview\nObjective:\nReplace the application's current ephemeral, file-based image management with a robust, scalable, and persistent system using Google Cloud services. This ensures all uploaded images are saved permanently and visible to all users of the application, creating a shared, collaborative asset library.\n\nCore Principles:\n- Persistence: Image binaries and metadata must survive sessions and deployments.\n- Scalability: The system must handle growing numbers of images and users without degradation.\n- Security: Upload and viewing access must be controlled and secure.\n- Centralization: Maintain a single source of truth for all image assets.\n\n2. Architecture Blueprint\nThe system is composed of interconnected Google Cloud services:\n- Persistent Storage → **Google Cloud Storage (GCS)**: securely stores raw image files (binaries).\n- Metadata Database → **Firestore**: stores metadata (uploader, timestamp, GCS URL, tags) — fast and queryable.\n- Backend API → **Cloud Functions (2nd Gen)**: secure HTTP endpoints for upload URLs and metadata management.\n- Authentication → **Firebase Authentication** (optional but recommended): manages user identities.\n- Frontend → **AI Studio Web App**: handles uploads and gallery viewing, communicating with the Cloud Functions API.\n\nData Flow (Upload):\n1. User selects an image in the frontend.\n2. Frontend requests a temporary upload URL from the Cloud Function API.\n3. Cloud Function generates a signed GCS upload URL and returns it.\n4. Frontend uploads the image directly to GCS via the signed URL.\n5. On success, frontend calls the Cloud Function to record metadata (including the GCS path) in Firestore.\n\n3. Security & Best Practices\n- **No Public Buckets**: Access only through short-lived signed URLs.\n- **Server-Side Validation**: Verify MIME type, size, and authentication before issuing URLs.\n- **CORS Policy**: Restrict allowed origins to the app domain.\n- **IAM Permissions**: Use minimal roles (e.g., `roles/storage.objectCreator`, `roles/datastore.user`).\n- **Environment Variables**: Store sensitive settings in Cloud Function environment, not code.\n\n4. Backend Implementation (Cloud Function)\n\n**index.js (Node.js)**\n```js\nconst functions = require('@google-cloud/functions-framework');\nconst { Storage } = require('@google-cloud/storage');\nconst { Firestore } = require('@google-cloud/firestore');\nconst { v4: uuidv4 } = require('uuid');\n\nconst storage = new Storage();\nconst firestore = new Firestore();\nconst bucketName = process.env.GCS_BUCKET_NAME;\nconst collectionName = 'images';\n\n// Generate a secure URL for uploading a file\nfunctions.http('generateUploadUrl', async (req, res) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Methods', 'POST');\n  res.set('Access-Control-Allow-Headers', 'Content-Type');\n  if (req.method === 'OPTIONS') return res.status(204).send('');\n\n  const { fileName, contentType } = req.body;\n  if (!fileName || !contentType || !contentType.startsWith('image/')) {\n    return res.status(400).send('Invalid request.');\n  }\n\n  const fileId = uuidv4();\n  const filePath = `uploads/${fileId}-${fileName}`;\n  const file = storage.bucket(bucketName).file(filePath);\n\n  const options = {\n    version: 'v4',\n    action: 'write',\n    expires: Date.now() + 15 * 60 * 1000,\n    contentType,\n  };\n\n  try {\n    const [url] = await file.getSignedUrl(options);\n    res.status(200).send({ uploadUrl: url, filePath });\n  } catch (err) {\n    console.error(err);\n    res.status(500).send('Error generating signed URL.');\n  }\n});\n\n// Save metadata after upload\nfunctions.http('saveImageMetadata', async (req, res) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Methods', 'POST');\n  res.set('Access-Control-Allow-Headers', 'Content-Type');\n  if (req.method === 'OPTIONS') return res.status(204).send('');\n\n  const { filePath, title, description, uploader } = req.body;\n  if (!filePath || !title) return res.status(400).send('Missing metadata.');\n\n  const publicUrl = `https://storage.googleapis.com/${bucketName}/${filePath}`;\n  const docRef = firestore.collection(collectionName).doc();\n  await docRef.set({\n    id: docRef.id,\n    gcsPath: filePath,\n    url: publicUrl,\n    title,\n    description,\n    uploader: uploader || 'anonymous',\n    timestamp: Firestore.FieldValue.serverTimestamp(),\n  });\n  res.status(200).send({ success: true });\n});\n\n// List all images\nfunctions.http('getGalleryImages', async (req, res) => {\n  res.set('Access-Control-Allow-Origin', '*');\n  const snapshot = await firestore.collection(collectionName).orderBy('timestamp', 'desc').get();\n  res.status(200).send(snapshot.docs.map(doc => doc.data()));\n});\n```\n\n**package.json**\n```json\n{\n  \"name\": \"image-gallery-backend\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"@google-cloud/functions-framework\": \"^3.0.0\",\n    \"@google-cloud/firestore\": \"^7.0.0\",\n    \"@google-cloud/storage\": \"^7.0.0\",\n    \"uuid\": \"^9.0.0\"\n  }\n}\n```\n\n5. Frontend Refactor\n\n**ImageUploadForm.tsx** (new upload workflow):\n```ts\nconst UPLOAD_URL_ENDPOINT = 'YOUR_CLOUD_FUNCTION_URL_generateUploadUrl';\nconst SAVE_METADATA_ENDPOINT = 'YOUR_CLOUD_FUNCTION_URL_saveImageMetadata';\n\nconst handleSubmit = async (e: React.FormEvent) => {\n  e.preventDefault();\n  if (!selectedFile || !title) return setError('File and title required');\n  setIsProcessing(true);\n\n  try {\n    const urlRes = await fetch(UPLOAD_URL_ENDPOINT, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ fileName: selectedFile.name, contentType: selectedFile.type }),\n    });\n    const { uploadUrl, filePath } = await urlRes.json();\n\n    await fetch(uploadUrl, {\n      method: 'PUT',\n      headers: { 'Content-Type': selectedFile.type },\n      body: selectedFile,\n    });\n\n    await fetch(SAVE_METADATA_ENDPOINT, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ filePath, title, description, uploader: 'demo-user' }),\n    });\n\n    onUploadSuccess();\n  } catch (err) {\n    setError(err.message);\n  } finally {\n    setIsProcessing(false);\n  }\n};\n```\n\n**ImageGalleries.tsx** (load gallery):\n```ts\nconst GET_GALLERY_ENDPOINT = 'YOUR_CLOUD_FUNCTION_URL_getGalleryImages';\n\nconst loadGalleries = useCallback(async () => {\n  setIsLoadingGalleries(true);\n  try {\n    const response = await fetch(GET_GALLERY_ENDPOINT);\n    const imagesFromDb = await response.json();\n    setAllImages(imagesFromDb);\n  } catch (e) {\n    console.error(e);\n  } finally {\n    setIsLoadingGalleries(false);\n  }\n}, []);\n\nuseEffect(() => { loadGalleries(); }, [loadGalleries]);\n```\n",
  "requestFramePermissions": []
}