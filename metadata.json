{
  "name": "Pathology Learning Module: Granulomatous Diseases",
  "description": "An interactive, all-inclusive didactic educational experience for pathology residents on granulomatous diseases of the lung, built using the ADDIE model of instructional design. Instruction Set: Implementing a Persistent, Multi-User Image Gallery in Google AI Studio\n1. System Design Overview\nObjective:\nTo replace the application's current ephemeral, file-based image management with a robust, scalable, and persistent system using Google Cloud services. This will ensure all uploaded images are saved permanently and are visible to all users of the application, creating a shared, collaborative asset library.\nCore Principles:\nPersistence: Image binaries and their metadata must survive sessions and deployments.\nScalability: The system must handle a growing number of images and users without performance degradation.\nSecurity: Access to upload and view images must be controlled and secure.\nCentralization: A single source of truth for all image assets.\n2. Architecture Blueprint\nThe system will be composed of the following interconnected Google Cloud services:\nComponent\tService\tPurpose\nPersistent Storage\tGoogle Cloud Storage (GCS)\tSecurely stores the raw image files (binaries). This is our scalable \"file system in the cloud.\"\nMetadata Database\tFirestore\tStores information about each image (e.g., uploader, timestamp, GCS URL, tags). Fast, scalable, and queryable.\nBackend API\tCloud Functions (2nd Gen)\tProvides secure HTTP endpoints for the frontend to request upload URLs, and to list/manage image metadata.\nAuthentication\tFirebase Authentication\t(Optional but Recommended) Manages user identities to associate uploads with specific users.\nFrontend Application\tAI Studio Web App\tThe user interface for uploading images and viewing the gallery. Interacts with the Cloud Function API.\nData Flow (Upload):\nUser selects an image in the Frontend App.\nFrontend requests a secure, temporary upload URL from the Cloud Function API.\nCloud Function generates a Signed URL for a specific path in the GCS Bucket and returns it to the frontend.\nFrontend uploads the image file directly to GCS using the signed URL.\nUpon successful upload, the frontend notifies the Cloud Function API, which then writes the image's metadata (including its final GCS path) to the Firestore database.\n3. Security & Best Practices\nNever Use Public Buckets: GCS buckets should remain private. Access is granted exclusively through short-lived Signed URLs. This is the most critical security principle.\nServer-Side Validation: The Cloud Function must validate all incoming requests, including file type (MIME check) and size, before generating an upload URL.\nCORS Policy: The GCS bucket's CORS (Cross-Origin Resource Sharing) policy must be configured to only allow uploads from the application's specific domain.\nIAM Permissions: The Cloud Function's service account must have the minimum required permissions (e.g., roles/storage.objectCreator and roles/datastore.user).\nEnvironment Variables: All sensitive information (project ID, bucket name) must be stored as environment variables in the Cloud Function, not hardcoded.\n4. Backend Implementation (Cloud Function)\nindex.js (Node.js)\ncode\nJavaScript\nconst functions = require('@google-cloud/functions-framework');\nconst { Storage } = require('@google-cloud/storage');\nconst { Firestore } = require('@google-cloud/firestore');\nconst { v4: uuidv4 } = require('uuid');\n\nconst storage = new Storage();\nconst firestore = new Firestore();\nconst bucketName = process.env.GCS_BUCKET_NAME; // Set in environment variables\nconst collectionName = 'images';\n\n// Function to generate a secure URL for uploading a file\nfunctions.http('generateUploadUrl', async (req, res) => {\n  // Allow CORS\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Methods', 'POST');\n  res.set('Access-Control-Allow-Headers', 'Content-Type');\n\n  if (req.method === 'OPTIONS') {\n    res.status(204).send('');\n    return;\n  }\n\n  const { fileName, contentType } = req.body;\n  if (!fileName || !contentType || !contentType.startsWith('image/')) {\n    res.status(400).send('Invalid request: Missing or invalid file details.');\n    return;\n  }\n\n  const fileId = uuidv4();\n  const filePath = `uploads/${fileId}-${fileName}`;\n  const file = storage.bucket(bucketName).file(filePath);\n\n  const options = {\n    version: 'v4',\n    action: 'write',\n    expires: Date.now() + 15 * 60 * 1000, // 15 minutes\n    contentType: contentType,\n  };\n\n  try {\n    const [url] = await file.getSignedUrl(options);\n    res.status(200).send({\n      uploadUrl: url,\n      filePath: filePath // Send back the path to be saved later\n    });\n  } catch (error) {\n    console.error('Error generating signed URL:', error);\n    res.status(500).send('Could not create upload URL.');\n  }\n});\n\n// Function to save image metadata to Firestore after upload is complete\nfunctions.http('saveImageMetadata', async (req, res) => {\n  // Allow CORS\n  res.set('Access-Control-Allow-Origin', '*');\n  res.set('Access-Control-Allow-Methods', 'POST');\n  res.set('Access-Control-Allow-Headers', 'Content-Type');\n\n  if (req.method === 'OPTIONS') {\n    res.status(204).send('');\n    return;\n  }\n  \n  const { filePath, title, description, uploader } = req.body;\n  if (!filePath || !title) {\n    res.status(400).send('Invalid request: Missing metadata.');\n    return;\n  }\n\n  const publicUrl = `https://storage.googleapis.com/${bucketName}/${filePath}`;\n\n  const docRef = firestore.collection(collectionName).doc();\n  await docRef.set({\n    id: docRef.id,\n    gcsPath: filePath,\n    url: publicUrl,\n    title,\n    description,\n    uploader: uploader || 'anonymous',\n    timestamp: Firestore.FieldValue.serverTimestamp()\n  });\n\n  res.status(200).send({ success: true, message: 'Metadata saved.' });\n});\n\n// Function to list all images\nfunctions.http('getGalleryImages', async (req, res) => {\n  // Allow CORS\n  res.set('Access-Control-Allow-Origin', '*');\n  \n  const snapshot = await firestore.collection(collectionName).orderBy('timestamp', 'desc').get();\n  const images = snapshot.docs.map(doc => doc.data());\n  res.status(200).send(images);\n});\npackage.json\ncode\nJSON\n{\n  \"name\": \"image-gallery-backend\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"@google-cloud/functions-framework\": \"^3.0.0\",\n    \"@google-cloud/firestore\": \"^7.0.0\",\n    \"@google-cloud/storage\": \"^7.0.0\",\n    \"uuid\": \"^9.0.0\"\n  }\n}\n5. Frontend Implementation\nThe frontend needs to be refactored to communicate with these new cloud functions instead of the local file system or in-memory stores.\nRefactor ImageUploadForm.tsx\nThe onUpload handler needs to be completely changed.\ncode\nTypeScript\n// Inside ImageUploadForm.tsx\n\nconst UPLOAD_URL_ENDPOINT = 'YOUR_CLOUD_FUNCTION_URL_for_generateUploadUrl';\nconst SAVE_METADATA_ENDPOINT = 'YOUR_CLOUD_FUNCTION_URL_for_saveImageMetadata';\n\n// ...\n\nconst handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!selectedFile || !title) {\n        setError('An image and a title are required.');\n        return;\n    }\n    setIsProcessing(true);\n    setError(null);\n\n    try {\n        // Step 1: Get a signed URL from our backend\n        const urlResponse = await fetch(UPLOAD_URL_ENDPOINT, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                fileName: selectedFile.name,\n                contentType: selectedFile.type,\n            }),\n        });\n        if (!urlResponse.ok) throw new Error('Could not get upload URL.');\n        const { uploadUrl, filePath } = await urlResponse.json();\n\n        // Step 2: Upload the file directly to Google Cloud Storage\n        const uploadResponse = await fetch(uploadUrl, {\n            method: 'PUT',\n            headers: { 'Content-Type': selectedFile.type },\n            body: selectedFile,\n        });\n        if (!uploadResponse.ok) throw new Error('File upload failed.');\n\n        // Step 3: Save the metadata to Firestore via our backend\n        const metadataResponse = await fetch(SAVE_METADATA_ENDPOINT, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                filePath: filePath,\n                title: title,\n                description: description,\n                uploader: 'demo-user' // Replace with actual user later\n            }),\n        });\n        if (!metadataResponse.ok) throw new Error('Failed to save metadata.');\n        \n        // Let the parent component know the upload is done\n        onUploadSuccess();\n\n    } catch (err: any) {\n        setError(err.message);\n    } finally {\n        setIsProcessing(false);\n    }\n};\n\n// ... (rest of the form component)\nRefactor ImageGalleries.tsx\nThe loadGalleries function must fetch from the new getGalleryImages endpoint.\ncode\nTypeScript\n// Inside ImageGalleries.tsx\n\nconst GET_GALLERY_ENDPOINT = 'YOUR_CLOUD_FUNCTION_URL_for_getGalleryImages';\n\n// ...\n\nconst loadGalleries = useCallback(async () => {\n    setIsLoadingGalleries(true);\n    try {\n        const response = await fetch(GET_GALLERY_ENDPOINT);\n        if (!response.ok) throw new Error('Failed to fetch gallery.');\n        const imagesFromDb = await response.json();\n        \n        // The concept of \"official\" vs \"community\" can now be a field\n        // in the Firestore document, e.g., `category: 'official'`.\n        // For now, we'll treat them all as one gallery.\n        setAllImages(imagesFromDb);\n\n    } catch (e: any) {\n        console.error(e);\n        // Handle error state in UI\n    } finally {\n        setIsLoadingGalleries(false);\n    }\n}, []);\n\nuseEffect(() => {\n    loadGalleries();\n}, [loadGalleries]);\n\n// The onUploadSuccess callback for the form would simply be `loadGalleries`\n// to refresh the list after a new image is added.",
  "requestFramePermissions": []
}